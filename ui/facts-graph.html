<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://d3js.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src 'self' data:;">
  <title>Mind Map</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Jura:wght@400;500;600;700&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --border: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --accent: #22c55e;
      --accent-secondary: #10b981;
      --accent-hover: #16a34a;
      --radius: 18px;
      --radius-sm: 10px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Sora', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', system-ui, sans-serif;
      background:
        radial-gradient(ellipse at top right, rgba(16, 185, 129, 0.08) 0%, transparent 50%),
        radial-gradient(circle, rgba(148, 163, 184, 0.07) 1px, transparent 1px),
        var(--bg-primary);
      background-size: 100% 100%, 24px 24px, 100% 100%;
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    /* Header */
    header {
      background: var(--bg-secondary);
      padding: 10px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    header h1 {
      font-family: 'Jura', sans-serif;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .stats {
      font-size: 12px;
      color: var(--text-muted);
    }

    .header-btn {
      padding: 5px 12px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .header-btn:hover {
      background: var(--border);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .header-btn:active {
      transform: translateY(0);
    }

    /* Toolbar */
    .toolbar {
      display: flex;
      gap: 8px;
      padding: 8px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      align-items: center;
      flex-wrap: nowrap;
    }

    .toolbar label {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .toolbar select {
      padding: 5px 24px 5px 10px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23a1a1a6' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    .toolbar select:focus {
      border-color: var(--accent);
    }

    .toolbar button {
      padding: 5px 10px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      white-space: nowrap;
    }

    .toolbar button:hover {
      background: var(--border);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .toolbar button:active {
      transform: translateY(0);
    }

    .spacer { flex: 1; min-width: 8px; }

    /* Legend */
    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: nowrap;
      flex-shrink: 0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      transition: background 0.15s;
    }

    .legend-item:hover {
      background: var(--bg-tertiary);
    }

    .legend-color {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* Link legend */
    .link-legend {
      display: flex;
      gap: 10px;
      margin-left: 10px;
      padding-left: 10px;
      border-left: 1px solid var(--border);
      flex-shrink: 0;
    }

    .link-legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .link-sample {
      width: 24px;
      height: 12px;
      flex-shrink: 0;
    }

    .link-sample svg {
      width: 100%;
      height: 100%;
    }

    .link-sample.solid path { stroke: var(--text-muted); stroke-width: 2; fill: none; }
    .link-sample.dashed path {
      stroke: #22c55e;
      stroke-width: 2;
      stroke-dasharray: 4 2;
      fill: none;
    }
    .link-sample.dotted path {
      stroke: var(--text-muted);
      stroke-width: 2;
      stroke-dasharray: 2 2;
      fill: none;
      opacity: 0.6;
    }

    /* Graph Container */
    #graph-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background:
        radial-gradient(ellipse 120% 120% at 50% 50%,
          var(--bg-secondary) 0%,
          var(--bg-primary) 40%,
          #0b1120 100%);
      background-color: var(--bg-primary);
    }

    /* Soft vignette - very gradual fade */
    #graph-container::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse 100% 100% at 50% 50%,
        transparent 0%,
        transparent 30%,
        rgba(0, 0, 0, 0.1) 60%,
        rgba(0, 0, 0, 0.25) 100%);
      pointer-events: none;
      z-index: 1;
    }

    /* Film grain texture overlay */
    #graph-container::after {
      content: '';
      position: absolute;
      inset: 0;
      opacity: 0.035;
      pointer-events: none;
      z-index: 1;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    }

    #graph {
      width: 100%;
      height: 100%;
      position: relative;
      z-index: 2;
    }

    /* Node styling */
    .node {
      cursor: pointer;
    }

    /* Main blob body - soft translucent appearance */
    .node .blob {
      transition: filter 0.3s ease;
    }

    /* Outer membrane - subtle cell wall */
    .node .blob-membrane {
      fill: none;
      stroke-width: 1px;
      opacity: 0.35;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    /* Inner nucleus highlight */
    .node .blob-nucleus {
      opacity: 0.4;
    }

    .node.highlighted .blob {
      filter: url(#glow);
    }

    .node.highlighted .blob-membrane {
      opacity: 0.8;
      stroke-width: 2px;
    }

    .node.dimmed {
      opacity: 0.15;
    }

    .node text {
      font-size: 10px;
      fill: var(--text-secondary);
      pointer-events: none;
      text-anchor: middle;
      transition: opacity 0.2s ease;
    }

    .node.dimmed text {
      opacity: 0.3;
    }

    /* Link styling */
    .link {
      fill: none;
      stroke-opacity: 0.5;
      transition: all 0.2s ease;
    }

    .link.category { stroke: #4a4a55; }
    .link.semantic { stroke: #22c55e; stroke-dasharray: 5, 3; }
    .link.keyword { stroke: #3a3a45; stroke-dasharray: 2, 2; stroke-opacity: 0.4; }

    .link.highlighted {
      stroke-opacity: 1;
      stroke-width: 2px !important;
    }

    .link.highlighted.semantic { stroke: var(--accent-hover); }
    .link.highlighted.category { stroke: #7a7a85; }

    .link.dimmed {
      stroke-opacity: 0.08;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
      max-width: 260px;
      font-size: 11px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 100;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    }

    .tooltip.visible { opacity: 1; }

    .tooltip-category {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 4px;
    }

    .tooltip-subject {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .tooltip-content {
      color: var(--text-secondary);
      line-height: 1.4;
    }

    /* Detail Panel */
    .detail-panel {
      position: absolute;
      bottom: 16px;
      left: 16px;
      right: 16px;
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px 16px;
      max-height: 180px;
      overflow-y: auto;
      display: none;
      animation: slideUp 0.25s ease;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.4);
      z-index: 100;
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(16px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .detail-panel.visible { display: block; }

    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .detail-category {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      padding: 3px 8px;
      border-radius: 4px;
    }

    .detail-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .detail-close:hover { color: var(--text-primary); }

    .detail-subject {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .detail-content {
      color: var(--text-secondary);
      line-height: 1.5;
      font-size: 12px;
    }

    .detail-connections {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      gap: 12px;
    }

    .detail-connections span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    /* Empty State */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      gap: 12px;
      padding: 40px;
    }

    .empty-state svg {
      width: 56px;
      height: 56px;
      opacity: 0.25;
    }

    .empty-state p {
      font-size: 13px;
      text-align: center;
      line-height: 1.5;
    }

    /* Focus mode hint */
    .hint {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 6px 14px;
      font-size: 10px;
      color: var(--text-muted);
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 100;
    }

    .hint.visible { opacity: 1; }
  </style>
</head>
<body>
  <header>
    <div style="display: flex; align-items: center; gap: 16px;">
      <h1>Mind Map</h1>
      <div class="stats" id="stats"></div>
    </div>
    <button class="header-btn" onclick="playNormalClick(); window.close()">Done</button>
  </header>

  <div class="toolbar">
    <label>Filter:</label>
    <select id="category-filter" onchange="filterByCategory()">
      <option value="all">All Categories</option>
    </select>

    <button onclick="playNormalClick(); resetZoom()">Reset</button>
    <button onclick="playNormalClick(); loadGraphData()">Refresh</button>

    <div class="spacer"></div>

    <div class="link-legend">
      <div class="link-legend-item">
        <div class="link-sample solid"><svg viewBox="0 0 24 12"><path d="M 2 8 Q 12 2 22 6"/></svg></div>
        <span>Category</span>
      </div>
      <div class="link-legend-item">
        <div class="link-sample dashed"><svg viewBox="0 0 24 12"><path d="M 2 6 Q 12 10 22 4"/></svg></div>
        <span>Semantic</span>
      </div>
      <div class="link-legend-item">
        <div class="link-sample dotted"><svg viewBox="0 0 24 12"><path d="M 2 4 Q 12 10 22 6"/></svg></div>
        <span>Keyword</span>
      </div>
    </div>
  </div>

  <div id="graph-container">
    <svg id="graph">
      <defs>
        <!-- Glow filter for highlighted nodes -->
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- Gooey/liquid amoeba filter - creates soft organic edges -->
        <filter id="gooey" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur"/>
          <feColorMatrix in="blur" type="matrix"
            values="1 0 0 0 0
                    0 1 0 0 0
                    0 0 1 0 0
                    0 0 0 19 -9" result="gooey"/>
          <feComposite in="SourceGraphic" in2="gooey" operator="atop"/>
        </filter>

        <!-- Soft inner glow for depth -->
        <filter id="amoeba-glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
          <feOffset in="blur" dx="1" dy="1" result="offsetBlur"/>
          <feFlood flood-color="white" flood-opacity="0.15" result="color"/>
          <feComposite in="color" in2="offsetBlur" operator="in" result="innerGlow"/>
          <feMerge>
            <feMergeNode in="SourceGraphic"/>
            <feMergeNode in="innerGlow"/>
          </feMerge>
        </filter>

        <!-- Combined organic blob filter -->
        <filter id="organic-blob" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" result="blur"/>
          <feColorMatrix in="blur" type="matrix"
            values="1 0 0 0 0
                    0 1 0 0 0
                    0 0 1 0 0
                    0 0 0 18 -7" result="gooey"/>
        </filter>

        <!-- Radial gradients for each category - translucent jelly-like amoeba colors -->
        <radialGradient id="amoeba-gradient-cyan" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#cffafe" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#22d3ee" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#06b6d4" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#0891b2" stop-opacity="0.08"/>
        </radialGradient>
        <radialGradient id="amoeba-gradient-green" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#bbf7d0" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#4ade80" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#22c55e" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#16a34a" stop-opacity="0.08"/>
        </radialGradient>
        <radialGradient id="amoeba-gradient-orange" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#fef3c7" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#fbbf24" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#f59e0b" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#d97706" stop-opacity="0.08"/>
        </radialGradient>
        <radialGradient id="amoeba-gradient-pink" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#fce7f3" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#f472b6" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#ec4899" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#db2777" stop-opacity="0.08"/>
        </radialGradient>
        <radialGradient id="amoeba-gradient-violet" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#ede9fe" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#a78bfa" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#8b5cf6" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#7c3aed" stop-opacity="0.08"/>
        </radialGradient>
        <radialGradient id="amoeba-gradient-gray" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#e5e7eb" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#9ca3af" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#6b7280" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#4b5563" stop-opacity="0.08"/>
        </radialGradient>
        <radialGradient id="amoeba-gradient-red" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#fee2e2" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#f87171" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#ef4444" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#dc2626" stop-opacity="0.08"/>
        </radialGradient>
        <radialGradient id="amoeba-gradient-teal" cx="30%" cy="30%" r="70%" fx="20%" fy="20%">
          <stop offset="0%" stop-color="#ccfbf1" stop-opacity="0.7"/>
          <stop offset="30%" stop-color="#2dd4bf" stop-opacity="0.45"/>
          <stop offset="60%" stop-color="#14b8a6" stop-opacity="0.25"/>
          <stop offset="100%" stop-color="#0d9488" stop-opacity="0.08"/>
        </radialGradient>
      </defs>
    </svg>
    <div class="tooltip" id="tooltip"></div>
    <div class="detail-panel" id="detail-panel"></div>
    <div class="hint" id="hint">Double-click node to focus</div>
  </div>

  <!-- Click Sound -->
  <audio id="normal-click-sound" preload="auto" src="../assets/normal-click.mp3"></audio>

  <script>
    // Click sound
    const normalClickSound = document.getElementById('normal-click-sound');
    function playNormalClick() {
      if (normalClickSound) {
        normalClickSound.currentTime = 0;
        normalClickSound.play().catch(() => {});
      }
    }
    document.addEventListener('click', (e) => {
      if (e.target.closest('button, .toggle, .tab, .legend-item')) {
        playNormalClick();
      }
    });

    // Category colors
    const CATEGORY_COLORS = {
      user_info: '#06b6d4',
      preferences: '#22c55e',
      projects: '#f59e0b',
      people: '#f472b6',
      work: '#8b5cf6',
      notes: '#64748b',
      decisions: '#ef4444',
      other: '#14b8a6'
    };

    // Category to gradient mapping
    const CATEGORY_GRADIENTS = {
      user_info: 'url(#amoeba-gradient-cyan)',
      preferences: 'url(#amoeba-gradient-green)',
      projects: 'url(#amoeba-gradient-orange)',
      people: 'url(#amoeba-gradient-pink)',
      work: 'url(#amoeba-gradient-violet)',
      notes: 'url(#amoeba-gradient-gray)',
      decisions: 'url(#amoeba-gradient-red)',
      other: 'url(#amoeba-gradient-teal)'
    };

    let graphData = { nodes: [], links: [] };
    let simulation = null;
    let svg, g, zoom;
    let currentFilter = 'all';
    let nodeElements, linkElements;
    let focusedNode = null;
    let organicAnimationId = null;
    let organicTime = 0;

    // Organic movement parameters for each node (generated on render)
    let nodeOrganicParams = new Map();
    let nodeSizesMap = new Map(); // Store node sizes for animation
    let nodeLinksMap = new Map(); // Map of node ID -> connected link elements (for fast drag updates)

    // Organic floating animation - makes nodes feel alive
    function startOrganicAnimation() {
      if (organicAnimationId) cancelAnimationFrame(organicAnimationId);

      function animate() {
        organicTime += 0.012; // Slow, dreamy movement

        if (nodeElements) {
          nodeElements.each(function(d) {
            const params = nodeOrganicParams.get(d.id);
            if (params && d.x !== undefined && d.y !== undefined) {
              // Skip position update if node is being dragged (fx is set)
              // Drag handler manages position during drag
              if (d.fx == null) {
                const driftX = Math.sin(organicTime * params.freqX + params.phaseX) * params.amplitudeX +
                              Math.sin(organicTime * params.freqX * 0.7 + params.phaseX * 1.3) * params.amplitudeX * 0.5;
                const driftY = Math.cos(organicTime * params.freqY + params.phaseY) * params.amplitudeY +
                              Math.cos(organicTime * params.freqY * 0.6 + params.phaseY * 0.8) * params.amplitudeY * 0.5;
                this.setAttribute('transform', `translate(${d.x + driftX}, ${d.y + driftY})`);
              }

              // Always morph the blob shape
              const radius = nodeSizesMap.get(d.id) || 14;
              const blobPath = generateBlobPath(radius, params, organicTime);
              const blob = d3.select(this).select('.blob');
              const membrane = d3.select(this).select('.blob-membrane');
              if (blob.size()) blob.attr('d', blobPath);
              if (membrane.size()) membrane.attr('d', blobPath);
            }
          });

          // Update links not connected to dragged node
          if (linkElements) {
            linkElements.each(function(d) {
              // Skip if either endpoint is being dragged - drag handler updates these
              if (d.source.fx != null || d.target.fx != null) return;

              const sourceParams = nodeOrganicParams.get(d.source.id);
              const targetParams = nodeOrganicParams.get(d.target.id);

              if (sourceParams && targetParams) {
                const srcDriftX = Math.sin(organicTime * sourceParams.freqX + sourceParams.phaseX) * sourceParams.amplitudeX +
                                 Math.sin(organicTime * sourceParams.freqX * 0.7 + sourceParams.phaseX * 1.3) * sourceParams.amplitudeX * 0.5;
                const srcDriftY = Math.cos(organicTime * sourceParams.freqY + sourceParams.phaseY) * sourceParams.amplitudeY +
                                 Math.cos(organicTime * sourceParams.freqY * 0.6 + sourceParams.phaseY * 0.8) * sourceParams.amplitudeY * 0.5;
                const tgtDriftX = Math.sin(organicTime * targetParams.freqX + targetParams.phaseX) * targetParams.amplitudeX +
                                 Math.sin(organicTime * targetParams.freqX * 0.7 + targetParams.phaseX * 1.3) * targetParams.amplitudeX * 0.5;
                const tgtDriftY = Math.cos(organicTime * targetParams.freqY + targetParams.phaseY) * targetParams.amplitudeY +
                                 Math.cos(organicTime * targetParams.freqY * 0.6 + targetParams.phaseY * 0.8) * targetParams.amplitudeY * 0.5;

                this.setAttribute('d', generateOrganicLinkPath(
                  d.source.x + srcDriftX, d.source.y + srcDriftY,
                  d.target.x + tgtDriftX, d.target.y + tgtDriftY,
                  d.curveOffset || 0,
                  organicTime,
                  d.curvePhase || 0,
                  d.curveFreq || 0.5,
                  d.linkParams
                ));
              }
            });
          }
        }

        organicAnimationId = requestAnimationFrame(animate);
      }

      animate();
    }

    function stopOrganicAnimation() {
      if (organicAnimationId) {
        cancelAnimationFrame(organicAnimationId);
        organicAnimationId = null;
      }
    }

    // Generate random organic movement parameters for a node
    function generateOrganicParams() {
      return {
        freqX: 0.3 + Math.random() * 0.4,      // Different frequencies for each node
        freqY: 0.25 + Math.random() * 0.35,
        phaseX: Math.random() * Math.PI * 2,   // Random starting phase
        phaseY: Math.random() * Math.PI * 2,
        amplitudeX: 2 + Math.random() * 3,     // Subtle movement range (2-5 pixels)
        amplitudeY: 2 + Math.random() * 3,
        // Blob shape parameters
        blobWaves: 3 + Math.floor(Math.random() * 4),  // 3-6 waves around the blob
        blobPhases: Array.from({length: 6}, () => Math.random() * Math.PI * 2),
        blobAmplitudes: Array.from({length: 6}, () => 0.15 + Math.random() * 0.25),
        blobMorphSpeed: 0.3 + Math.random() * 0.4  // How fast the blob morphs
      };
    }

    // Generate an amoeba/blob SVG path - organic cell-like shape
    function generateBlobPath(radius, params, time = 0) {
      const points = 48; // Smoothness of the blob
      const pathPoints = [];

      for (let i = 0; i < points; i++) {
        const angle = (i / points) * Math.PI * 2;

        // Start with base radius
        let r = radius;

        // Primary organic deformation (2-4 lobes like a real amoeba)
        const lobes = 2 + (params.blobWaves % 3); // 2-4 main lobes
        const lobePhase = params.blobPhases[0] || 0;
        const lobeAmp = 0.25 + (params.blobAmplitudes[0] || 0) * 0.15;
        r += radius * lobeAmp * Math.sin(angle * lobes + lobePhase + time * params.blobMorphSpeed * 0.3);

        // Secondary wobble (faster, smaller)
        const wobblePhase = params.blobPhases[1] || 0;
        const wobbleAmp = 0.12 + (params.blobAmplitudes[1] || 0) * 0.08;
        r += radius * wobbleAmp * Math.sin(angle * (lobes + 2) + wobblePhase + time * params.blobMorphSpeed * 0.5);

        // Tertiary detail (subtle organic texture)
        const detailPhase = params.blobPhases[2] || 0;
        r += radius * 0.06 * Math.sin(angle * 7 + detailPhase + time * 0.2);
        r += radius * 0.04 * Math.cos(angle * 5 + params.blobPhases[3] + time * 0.15);

        // Pseudopod extensions (random bulges like amoeba arms)
        for (let p = 0; p < 2; p++) {
          const podAngle = params.blobPhases[p + 3] || p * Math.PI;
          const podWidth = 0.4 + Math.random() * 0.2;
          const angleDiff = Math.abs(Math.sin((angle - podAngle - time * 0.1) / 2));
          if (angleDiff < podWidth) {
            const podStrength = (1 - angleDiff / podWidth) * 0.15;
            r += radius * podStrength * Math.sin(time * params.blobMorphSpeed * 0.4 + p);
          }
        }

        // Ensure minimum radius
        r = Math.max(r, radius * 0.6);

        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        pathPoints.push({x, y});
      }

      // Create smooth curve through points using catmull-rom to bezier conversion
      return smoothBlobPath(pathPoints);
    }

    // Convert points to a smooth closed SVG path
    function smoothBlobPath(points) {
      if (points.length < 3) return '';

      const closed = [...points, points[0], points[1], points[2]];

      let path = `M ${points[0].x.toFixed(2)} ${points[0].y.toFixed(2)}`;

      for (let i = 0; i < points.length; i++) {
        const p0 = closed[i];
        const p1 = closed[i + 1];
        const p2 = closed[i + 2];
        const p3 = closed[i + 3];

        // Catmull-Rom to Bezier conversion
        const cp1x = p1.x + (p2.x - p0.x) / 6;
        const cp1y = p1.y + (p2.y - p0.y) / 6;
        const cp2x = p2.x - (p3.x - p1.x) / 6;
        const cp2y = p2.y - (p3.y - p1.y) / 6;

        path += ` C ${cp1x.toFixed(2)} ${cp1y.toFixed(2)}, ${cp2x.toFixed(2)} ${cp2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
      }

      return path + ' Z';
    }

    // Generate organic tissue-like link path between two points
    function generateOrganicLinkPath(x1, y1, x2, y2, curveOffset, time, phase, freq, linkParams) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < 1) return `M ${x1} ${y1} L ${x2} ${y2}`;

      // Perpendicular vector for curve offset
      const px = -dy / dist;
      const py = dx / dist;

      // Use link-specific params for consistent organic shape
      const params = linkParams || {};
      const segments = params.segments || 8;
      const waveAmps = params.waveAmps || [0.1, 0.05, 0.03];
      const waveFreqs = params.waveFreqs || [2, 4, 7];
      const wavePhases = params.wavePhases || [0, 1.5, 3];

      // Generate points along the path with organic displacement
      const points = [];
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;

        // Base position along straight line
        let x = x1 + dx * t;
        let y = y1 + dy * t;

        // Main curve offset (larger in middle, tapers at ends)
        const taper = Math.sin(t * Math.PI); // 0 at ends, 1 in middle
        const baseOffset = curveOffset * taper;

        // Animated breathing/pulsing of the main curve
        const breathe = Math.sin(time * freq * 0.3 + phase) * 5 * taper;

        // Multiple wave harmonics for organic tissue feel
        let waveOffset = 0;
        for (let w = 0; w < waveAmps.length; w++) {
          const amp = waveAmps[w] * dist * taper;
          const waveFreq = waveFreqs[w];
          const wavePhase = wavePhases[w];
          // Time-animated waves
          waveOffset += amp * Math.sin(t * Math.PI * waveFreq + time * 0.4 * (w + 1) + wavePhase + phase);
        }

        // Subtle random wobble for organic feel
        const wobble = Math.sin(t * 13 + phase * 2 + time * 0.5) * 2 * taper;

        // Apply all offsets perpendicular to line direction
        const totalOffset = baseOffset + breathe + waveOffset + wobble;
        x += px * totalOffset;
        y += py * totalOffset;

        points.push({ x, y });
      }

      // Convert to smooth bezier path
      return smoothTissuePath(points);
    }

    // Create smooth tissue-like path through points
    function smoothTissuePath(points) {
      if (points.length < 2) return '';
      if (points.length === 2) {
        return `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)} L ${points[1].x.toFixed(1)} ${points[1].y.toFixed(1)}`;
      }

      let path = `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;

      // Use Catmull-Rom spline for smooth organic curves
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[Math.max(0, i - 1)];
        const p1 = points[i];
        const p2 = points[Math.min(points.length - 1, i + 1)];
        const p3 = points[Math.min(points.length - 1, i + 2)];

        // Catmull-Rom to cubic bezier
        const tension = 0.3; // Lower = smoother curves
        const cp1x = p1.x + (p2.x - p0.x) * tension;
        const cp1y = p1.y + (p2.y - p0.y) * tension;
        const cp2x = p2.x - (p3.x - p1.x) * tension;
        const cp2y = p2.y - (p3.y - p1.y) * tension;

        path += ` C ${cp1x.toFixed(1)} ${cp1y.toFixed(1)}, ${cp2x.toFixed(1)} ${cp2y.toFixed(1)}, ${p2.x.toFixed(1)} ${p2.y.toFixed(1)}`;
      }

      return path;
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      initGraph();
      loadGraphData();

      // Show hint briefly
      setTimeout(() => {
        document.getElementById('hint').classList.add('visible');
        setTimeout(() => document.getElementById('hint').classList.remove('visible'), 4000);
      }, 1500);
    });

    function initGraph() {
      const container = document.getElementById('graph-container');
      svg = d3.select('#graph');

      // Create zoom behavior
      zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
        });

      svg.call(zoom);

      // Click on background to unfocus
      svg.on('click', (event) => {
        if (event.target.tagName === 'svg') {
          unfocusAll();
          hideDetail();
        }
      });

      // Create main group for graph elements
      g = svg.append('g');

      // Handle window resize
      window.addEventListener('resize', () => {
        if (simulation) {
          const w = container.clientWidth;
          const h = container.clientHeight;
          simulation.force('center', d3.forceCenter(w / 2, h / 2));
          simulation.alpha(0.3).restart();
        }
      });
    }

    async function loadGraphData() {
      try {
        graphData = await window.pocketAgent.getGraphData();

        if (!graphData.nodes || graphData.nodes.length === 0) {
          showEmptyState();
          return;
        }

        updateStats();
        updateCategoryFilter();
        renderGraph();
      } catch (err) {
        console.error('Failed to load graph data:', err);
        showEmptyState();
      }
    }

    function updateStats() {
      const stats = document.getElementById('stats');
      stats.textContent = `${graphData.nodes.length} facts, ${graphData.links.length} connections`;
    }

    function updateCategoryFilter() {
      const select = document.getElementById('category-filter');
      const categories = [...new Set(graphData.nodes.map(n => n.category))];

      while (select.options.length > 1) select.remove(1);

      categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        select.appendChild(option);
      });
    }

    function filterByCategory() {
      currentFilter = document.getElementById('category-filter').value;
      renderGraph();
    }

    function renderGraph() {
      stopOrganicAnimation();
      g.selectAll('*').remove();
      nodeOrganicParams.clear();

      const container = document.getElementById('graph-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      // Filter data
      let filteredNodes = graphData.nodes;
      let filteredLinks = graphData.links;

      if (currentFilter !== 'all') {
        filteredNodes = graphData.nodes.filter(n => n.category === currentFilter);
        const nodeIds = new Set(filteredNodes.map(n => n.id));
        filteredLinks = graphData.links.filter(l =>
          nodeIds.has(l.source.id || l.source) && nodeIds.has(l.target.id || l.target)
        );
      }

      if (filteredNodes.length === 0) {
        showEmptyState();
        return;
      }

      // Create copies for simulation
      const nodes = filteredNodes.map(n => ({ ...n }));
      const links = filteredLinks.map(l => ({
        ...l,
        source: l.source.id !== undefined ? l.source.id : l.source,
        target: l.target.id !== undefined ? l.target.id : l.target
      }));

      // Generate organic movement parameters for each node
      nodes.forEach(n => {
        nodeOrganicParams.set(n.id, generateOrganicParams());
      });

      // Build adjacency map for quick neighbor lookup
      const adjacencyMap = new Map();
      nodes.forEach(n => adjacencyMap.set(n.id, new Set()));
      links.forEach(l => {
        const sid = l.source.id !== undefined ? l.source.id : l.source;
        const tid = l.target.id !== undefined ? l.target.id : l.target;
        adjacencyMap.get(sid)?.add(tid);
        adjacencyMap.get(tid)?.add(sid);
      });

      // Create simulation
      simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links)
          .id(d => d.id)
          .distance(d => 80 + 40 / (d.strength || 0.3))
          .strength(d => (d.strength || 0.3) * 0.8))
        .force('charge', d3.forceManyBody().strength(-250))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(35))
        .stop();

      // Pre-compute layout
      for (let i = 0; i < 300; i++) {
        simulation.tick();
      }

      // Create organic curved links (paths instead of lines)
      linkElements = g.append('g')
        .attr('class', 'links')
        .selectAll('path')
        .data(links)
        .join('path')
        .attr('class', d => `link ${d.type}`)
        .attr('stroke-width', d => Math.max(1.5, (d.strength || 0.3) * 2.5))
        .attr('fill', 'none')
        .each(function(d) {
          // Store random curve parameters for each link
          d.curveOffset = (Math.random() - 0.5) * 30; // Random curve direction & amount
          d.curvePhase = Math.random() * Math.PI * 2;
          d.curveFreq = 0.5 + Math.random() * 0.5;
          // Organic tissue parameters - unique per link for variety
          d.linkParams = {
            segments: 6 + Math.floor(Math.random() * 4), // 6-9 segments
            waveAmps: [
              0.06 + Math.random() * 0.06,  // Primary wave
              0.03 + Math.random() * 0.03,  // Secondary wave
              0.015 + Math.random() * 0.02  // Tertiary detail
            ],
            waveFreqs: [
              1.5 + Math.random() * 1.5,    // Slow wave
              3 + Math.random() * 2,        // Medium wave
              5 + Math.random() * 4         // Fast detail
            ],
            wavePhases: [
              Math.random() * Math.PI * 2,
              Math.random() * Math.PI * 2,
              Math.random() * Math.PI * 2
            ]
          };
          // Set initial path immediately
          d3.select(this).attr('d', generateOrganicLinkPath(
            d.source.x, d.source.y,
            d.target.x, d.target.y,
            d.curveOffset, 0, d.curvePhase, d.curveFreq, d.linkParams
          ));
        });

      // Build nodeLinksMap for fast drag updates
      nodeLinksMap.clear();
      nodes.forEach(n => nodeLinksMap.set(n.id, []));
      linkElements.each(function(link) {
        const sourceId = link.source.id;
        const targetId = link.target.id;
        const linkRef = { element: this, link };
        if (nodeLinksMap.has(sourceId)) nodeLinksMap.get(sourceId).push(linkRef);
        if (nodeLinksMap.has(targetId)) nodeLinksMap.get(targetId).push(linkRef);
      });

      // Create node groups
      nodeElements = g.append('g')
        .attr('class', 'nodes')
        .selectAll('.node')
        .data(nodes)
        .join('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.x}, ${d.y})`) // Initial position immediately
        .call(d3.drag()
          .on('start', dragStarted)
          .on('drag', dragged)
          .on('end', dragEnded));

      // Calculate node sizes based on connections
      const nodeSizes = new Map();
      nodes.forEach(n => {
        const connCount = adjacencyMap.get(n.id)?.size || 0;
        nodeSizes.set(n.id, Math.max(12, Math.min(24, 12 + connCount * 2.5)));
      });
      nodeSizesMap = nodeSizes; // Store for animation

      // Add amoeba blob shapes with translucent gradient fill
      nodeElements.append('path')
        .attr('class', 'blob')
        .attr('d', d => {
          const params = nodeOrganicParams.get(d.id);
          const radius = nodeSizes.get(d.id);
          return generateBlobPath(radius, params, 0);
        })
        .attr('fill', d => CATEGORY_GRADIENTS[d.category] || CATEGORY_GRADIENTS.other)
        .attr('stroke', 'none');

      // Add inner nucleus highlight (smaller, subtle)
      nodeElements.append('ellipse')
        .attr('class', 'blob-nucleus')
        .attr('cx', d => -nodeSizes.get(d.id) * 0.15)
        .attr('cy', d => -nodeSizes.get(d.id) * 0.15)
        .attr('rx', d => nodeSizes.get(d.id) * 0.25)
        .attr('ry', d => nodeSizes.get(d.id) * 0.2)
        .attr('fill', 'white')
        .attr('opacity', 0.35);

      // Add membrane outline for cell wall effect
      nodeElements.append('path')
        .attr('class', 'blob-membrane')
        .attr('d', d => {
          const params = nodeOrganicParams.get(d.id);
          const radius = nodeSizes.get(d.id);
          return generateBlobPath(radius, params, 0);
        })
        .attr('stroke', d => CATEGORY_COLORS[d.category] || CATEGORY_COLORS.other);

      // Add labels
      nodeElements.append('text')
        .attr('dy', d => nodeSizes.get(d.id) + 12)
        .text(d => truncate(d.subject, 14));

      // Event handlers
      nodeElements
        .on('mouseover', (event, d) => highlightNode(d, adjacencyMap))
        .on('mouseout', () => { if (!focusedNode) unhighlightAll(); })
        .on('click', (event, d) => {
          event.stopPropagation();
          showDetail(d, adjacencyMap);
        })
        .on('dblclick', (event, d) => {
          event.stopPropagation();
          focusNode(d, adjacencyMap);
        });

      // Start organic animation - layout is pre-computed so everything is in place
      startOrganicAnimation();

      // Initial zoom
      setTimeout(() => zoomToFit(), 600);
    }

    function highlightNode(d, adjacencyMap) {
      if (focusedNode) return; // Don't override focus mode

      const neighbors = adjacencyMap.get(d.id) || new Set();

      // Dim all nodes and links
      nodeElements.classed('dimmed', n => n.id !== d.id && !neighbors.has(n.id));
      nodeElements.classed('highlighted', n => n.id === d.id);

      linkElements.classed('dimmed', l => {
        const sid = l.source.id;
        const tid = l.target.id;
        return sid !== d.id && tid !== d.id;
      });
      linkElements.classed('highlighted', l => l.source.id === d.id || l.target.id === d.id);

      showTooltip(event, d);
    }

    function unhighlightAll() {
      nodeElements.classed('dimmed', false).classed('highlighted', false);
      linkElements.classed('dimmed', false).classed('highlighted', false);
      hideTooltip();
    }

    function focusNode(d, adjacencyMap) {
      focusedNode = d;
      highlightNode(d, adjacencyMap);
      hideTooltip();

      // Zoom to focused node area
      const container = document.getElementById('graph-container');
      const scale = 1.5;
      const x = container.clientWidth / 2 - d.x * scale;
      const y = container.clientHeight / 2 - d.y * scale;

      svg.transition()
        .duration(400)
        .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
    }

    function unfocusAll() {
      focusedNode = null;
      unhighlightAll();
    }

    function dragStarted(event, d) {
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
      d.x = event.x;
      d.y = event.y;

      // Synchronous DOM update - node
      this.setAttribute('transform', `translate(${d.x}, ${d.y})`);

      // Synchronous DOM update - connected links with fast bezier
      const connectedLinks = nodeLinksMap.get(d.id);
      if (connectedLinks) {
        for (const { element, link } of connectedLinks) {
          const x1 = link.source.x, y1 = link.source.y;
          const x2 = link.target.x, y2 = link.target.y;
          const dx = x2 - x1, dy = y2 - y1;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const px = -dy / dist, py = dx / dist;
          const off = link.curveOffset || 0;
          const mx = (x1 + x2) / 2 + px * off;
          const my = (y1 + y2) / 2 + py * off;
          element.setAttribute('d', `M${x1},${y1}Q${mx},${my},${x2},${y2}`);
        }
      }
    }

    function dragEnded(event, d) {
      d.fx = null;
      d.fy = null;
    }

    function showTooltip(event, d) {
      const tooltip = document.getElementById('tooltip');
      const color = CATEGORY_COLORS[d.category] || CATEGORY_COLORS.other;
      tooltip.innerHTML = `
        <div class="tooltip-category" style="color: ${color}">${d.category}</div>
        <div class="tooltip-subject">${escapeHtml(d.subject)}</div>
        <div class="tooltip-content">${escapeHtml(truncate(d.content, 80))}</div>
      `;
      tooltip.classList.add('visible');
      moveTooltip(event);
    }

    function moveTooltip(event) {
      const tooltip = document.getElementById('tooltip');
      const container = document.getElementById('graph-container');
      const rect = container.getBoundingClientRect();

      let x = event.clientX - rect.left + 12;
      let y = event.clientY - rect.top + 12;

      const tooltipRect = tooltip.getBoundingClientRect();
      if (x + tooltipRect.width > rect.width - 10) x = event.clientX - rect.left - tooltipRect.width - 12;
      if (y + tooltipRect.height > rect.height - 10) y = event.clientY - rect.top - tooltipRect.height - 12;

      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';
    }

    function hideTooltip() {
      document.getElementById('tooltip').classList.remove('visible');
    }

    function showDetail(d, adjacencyMap) {
      const panel = document.getElementById('detail-panel');
      const color = CATEGORY_COLORS[d.category] || CATEGORY_COLORS.other;

      const connections = graphData.links.filter(l =>
        (l.source.id || l.source) === d.id || (l.target.id || l.target) === d.id
      );

      const catCount = connections.filter(c => c.type === 'category').length;
      const semCount = connections.filter(c => c.type === 'semantic').length;
      const kwCount = connections.filter(c => c.type === 'keyword').length;

      panel.innerHTML = `
        <div class="detail-header">
          <div class="detail-category" style="background: ${color}20; color: ${color}">${d.category}</div>
          <button class="detail-close" onclick="playNormalClick(); hideDetail()">&times;</button>
        </div>
        <div class="detail-subject">${escapeHtml(d.subject)}</div>
        <div class="detail-content">${escapeHtml(d.content)}</div>
        <div class="detail-connections">
          ${catCount ? `<span><div class="link-sample solid"><svg viewBox="0 0 24 12"><path d="M 2 8 Q 12 2 22 6"/></svg></div>${catCount} category</span>` : ''}
          ${semCount ? `<span><div class="link-sample dashed"><svg viewBox="0 0 24 12"><path d="M 2 6 Q 12 10 22 4"/></svg></div>${semCount} semantic</span>` : ''}
          ${kwCount ? `<span><div class="link-sample dotted"><svg viewBox="0 0 24 12"><path d="M 2 4 Q 12 10 22 6"/></svg></div>${kwCount} keyword</span>` : ''}
        </div>
      `;

      panel.classList.add('visible');
    }

    function hideDetail() {
      document.getElementById('detail-panel').classList.remove('visible');
    }

    function resetZoom() {
      unfocusAll();
      zoomToFit();
    }

    function zoomToFit() {
      const container = document.getElementById('graph-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const bounds = g.node()?.getBBox();
      if (!bounds || bounds.width === 0 || bounds.height === 0) return;

      const midX = bounds.x + bounds.width / 2;
      const midY = bounds.y + bounds.height / 2;
      const scale = 0.85 / Math.max(bounds.width / width, bounds.height / height);
      const tx = width / 2 - scale * midX;
      const ty = height / 2 - scale * midY;

      svg.transition()
        .duration(500)
        .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(Math.min(scale, 1.5)));
    }

    function showEmptyState() {
      stopOrganicAnimation();
      document.getElementById('graph-container').innerHTML = `
        <div class="empty-state">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
            <circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/>
            <line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/>
            <line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/>
          </svg>
          <p>No facts stored yet.<br>Tell me things about yourself to build your knowledge graph.</p>
        </div>
      `;
    }

    function truncate(text, maxLength) {
      if (!text) return '';
      return text.length > maxLength ? text.slice(0, maxLength) + '...' : text;
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>
